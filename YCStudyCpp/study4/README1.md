## C++从0到1案例学习
#### 目录介绍
- 01.第一天：基础语法
- 02.第二天：运算符和表达式
- 03.第三天：判断和循环
- 04.第四天：数组和容器
- 05.第五天：指针和引用
- 06.第六天：函数实践
- 07.第七天：IO输入和输出
- 08.第八天：结构和类
- 09.第九天：继承和派生
- 10.第十天：多线程和并发
- 11.第十一天：线程安全锁
- 12.第十二天：内存分配堆和栈
- 13.第十三天：异常处理
- 14.第十四天：STL标准模板库
- 15.第十五天：设计模式
- 16.第十六天：程序调试
- 17.第十七天：网络通信
- 18.第十八天：综合案例


### 04.第四天：数组和容器
#### 4.1 数组介绍使用
- 4.1.1 数组基础使用
    - 4.1.1.1 声明数组，在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量
    - 4.1.1.2 初始化数组，可以逐个初始化数组，也可以使用一个初始化语句
    - 4.1.1.3 访问数组元素，数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。
- 4.1.2 C++中数组详解
    - 4.1.2.1 多维数组，C++ 支持多维数组。多维数组最简单的形式是二维数组。
    - 4.1.2.2 指向数组的指针，您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。
    - 4.1.2.3 传递数组给函数，您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。
    - 4.1.2.4 从函数返回数组，C++ 允许从函数返回数组。


#### 4.2 Vector向量
- 4.2.1 Vector向量使用
    - 4.2.1.1 为什么有Vector，C++ 中的 vector 是一种序列容器，它允许你在运行时动态地插入和删除元素。基于数组的数据结构，但它可以自动管理内存
    - 4.2.1.2 Vector基础函数，添加元素，访问元素，获取大小，迭代访问，删除元素，清空 Vector
    - 4.2.1.3 Vector综合实践，创建了一个整数向量，添加了几个元素，然后输出了向量内容、元素的访问、向量的大小等信息，并输出删除元素后的向量。


#### 4.3 容器使用介绍







#### 5.6 函数与引用
8.5.1 左值与右值 193
8.5.2 引用的概述 194
8.5.3 右值引用 195
8.6.1 使用引用传递参数 196
8.6.2 指针与引用 197
8.6.3 右值引用传递参数 199



#### 5.9 指针和引用练习题
8.7.1 使用左值引用实现整数排序 200
8.7.2 查找成绩不及格的学生 201
8.7.3 指针实现冒泡排序 202
8.7.4 使用指针插入元素 203
8.7.5 使用指针的指针输出字符串 204
8.7.6 为二维数组动态分配内存并释放 205
8.7.7 使用右值引用转换二进制为十进制 206



### 06.第六天：函数实践
#### 6.1 函数的定义
7.2.1 无参函数 142
7.2.2 有参函数 142
7.2.3 空函数 143

#### 6.2 返回语句
7.3.1 从函数返回 143
7.3.2 返回值 144


#### 6.3 函数参数
7.4.1 形式参数与实际参数 145
7.4.2 数组作函数参数 147
7.4.3 main参数 151


#### 6.4 函数的调用
7.5.1 函数调用方式 153
7.5.2 嵌套调用 153
7.5.3 递归调用 155



#### 6.5 内部和外部函数
7.6.1 内部函数 158
7.6.2 外部函数 158




#### 6.8 数组和容器练习题
6.5.1 相邻元素之和 129
6.5.2 选票系统 130
6.5.3 统计学生成绩 131
6.5.4 模拟比赛打分 132
6.5.5 矩阵的转置 133
6.5.6 设计魔方阵 135
6.5.7 统计各种字符个数 136




### 07.第七天：IO输入和输出




### 08.第八天：结构和类
#### 8.1 C++数据结构
- 8.1.1 struct结构类型
    - 8.1.1.1 为何设计结构，结构是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。
    - 8.1.1.2 定义结构，使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型
    - 8.1.1.3 访问结构成员，使用成员访问运算符（.）。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。
- 8.1.2 struct结构实践
    - 8.1.2.1 结构作为函数参数，把结构作为函数参数，传参方式与其他类型的变量或指针类似。
    - 8.1.2.2 指向结构的指针，可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似：struct Books *struct_pointer;
    - 8.1.2.3 typedef结构方式，可以为创建的类型取一个"别名"。
    - 8.1.2.4 . 与 -> 运算符，访问结构的成员时使用点运算符，而通过指针访问结构的成员时则使用箭头运算符。
    - 8.1.2.5 结构作为函数返回值，可以在函数中定义返回值为结构，对函数封装



#### 8.2 类和对象
- 8.2.1 类声明和实现
    - 8.2.1.1 类概述，C++ 支持面向对象程序设计。类用于指定对象的形式，是一种用户自定义的数据类型，它是一种封装了数据和函数的组合。
    - 8.2.1.2 类的声明与定义，定义一个类需要使用关键字 class，然后指定类的名称，并类的主体是包含在一对花括号中，主体包含类的成员变量和成员函数。
    - 8.2.1.3 类的实现，定义了一个名为Person的类。它有两个私有成员变量：name和age。我们使用构造函数来初始化这些成员变量。
    - 8.2.1.4 对象的声明，类提供了对象的蓝图，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。
- 8.2.2 构造函数
    - 8.2.2.1 构造函数概述，类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。
    - 8.2.2.2 带参数的构造函数，默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值
    - 8.2.2.3 析构函数，类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。
    - 8.2.2.4 拷贝构造函数，拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。
- 8.2.3 类访问修饰符
    - 8.2.3.1 类访问修饰符介绍，类成员的访问限制是通过在类主体内部对各个区域标记 public、private、protected 来指定的。
    - 8.2.3.2 访问修饰符继承中的特点，有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。



#### 8.3 类成员
- 8.3.1 访问类的属性
    - 8.3.1.1 访问类成员，类的对象的公共数据成员可以使用直接成员访问运算符 . 来访问。
    - 8.3.1.2 成员函数，成员函数可以定义在类定义内部，或者单独使用范围解析运算符 :: 来定义。
    - 8.3.1.3 内联成员函数，在类定义中定义的成员函数把函数声明为内联的，即便没有使用 inline 标识符。
    - 8.3.1.4 友元函数，类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。
    - 8.3.1.5 静态类成员，声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。
- 8.3.2 类成员其他
    - 8.3.2.1 隐藏的this指针，this是一个隐藏的指针，可以在类的成员函数中使用，它可以用来指向调用对象。
    - 8.3.2.2 指向类的指针，指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 ->，就像访问指向结构的指针一样。
    - 8.3.2.2 嵌套类
    - 8.3.2.3 局部类



#### 8.4 命名空间
- 8.4.1 命名空间实现
    - 8.4.1.1 命名空间场景介绍，引入了命名空间这个概念，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。
    - 8.4.1.2 定义命名空间，命名空间的定义使用关键字 namespace，后跟命名空间的名称。为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称
    - 8.4.1.3 using 指令，可以使用 using namespace 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。
    - 8.4.1.4 不连续的命名空间，命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中。
    - 8.4.1.5 嵌套的命名空间，命名空间可以嵌套，可以在一个命名空间中定义另一个命名空间。可以通过使用 :: 运算符来访问嵌套的命名空间中的成员







### 11.第十一天：线程安全锁



### 13.第十三天：异常处理
#### 13.1 异常声明和处理
- 13.1.1 异常简单使用
    - 13.1.1.1 异常的介绍，异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：try、catch、throw。
    - 13.1.1.2 抛出异常，可以使用 throw 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式
    - 13.1.1.3 捕获异常，catch 块跟在 try 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。
- 13.1.2 定义新异常
    - 13.1.2.1 C++标准的异常，C++ 提供了一系列标准的异常，定义在 <exception> 中，我们可以在程序中使用这些标准的异常。
    - 13.1.2.2 定义新的异常，可以通过继承和重载 exception 类来定义新的异常。


#### 13.2 异常体系说明
- 13.2.1 异常体系详解
    - 13.2.1.1 std::exception，该异常是所有标准 C++ 异常的父类。
    - 13.2.1.2 std::bad_alloc，该异常可以通过 new 抛出。
    - 13.2.1.3 std::bad_cast，该异常可以通过 dynamic_cast 抛出。
    - 13.2.1.4 std::bad_typeid，该异常可以通过 typeid 抛出。
    - 13.2.1.5 std::bad_exception，这在处理 C++ 程序中无法预期的异常时非常有用。
    - 13.2.1.6 std::logic_error，理论上可以通过读取代码来检测到的异常。
    - 13.2.1.7 std::runtime_error，理论上不可以通过读取代码来检测到的异常。
- 13.2.2 读取代码检测异常
    - 13.2.2.1 std::domain_error，当使用了一个无效的数学域时，会抛出该异常。
    - 13.2.2.2 std::invalid_argument，当使用了无效的参数时，会抛出该异常。
    - 13.2.2.3 std::length_error，当创建了太长的 std::string 时，会抛出该异常。
    - 13.2.2.4 std::out_of_range，该异常可以通过方法抛出，例如 std::vector 和 std::bitset<>::operator[]()。
- 13.2.3 不可通过读取代码检测异常
    - 13.2.3.1 std::overflow_error，当发生数学上溢时，会抛出该异常。
    - 13.2.3.2 std::range_error，当尝试存储超出范围的值时，会抛出该异常。
    - 13.2.3.3 std::underflow_error，当发生数学下溢时，会抛出该异常。






#### 13.3 异常捕获设计
- 13.3.1 异常捕获原理



### 14.第十四天：STL标准模板库


### 18.第十八天：程序调试
17.1 选择正确的调试方法 472
17.2 程序错误常见的4种类型 472
17.2.1 语法错误 472
17.2.2 连接错误 473
17.2.3 运行时错误 473
17.2.4 逻辑错误 474
17.3 调试工具的使用 475
17.3.1 创建调试程序 475
17.3.2 进入调试状态 476
17.3.3 监视窗口 477
17.3.4 调用堆栈窗口 477
17.3.5 内存窗口 478
17.3.6 变量窗口 478
17.3.7 寄存器窗口 478
17.3.8 反汇编窗口 479
17.4 调试的基本应用 479
17.4.1 变量的跟踪与查看 479
17.4.2 位置断点的使用 480


### 19.第十九天：网络通信
#### 19.1 TCP/IP协议
19.1.1 OSI参考模型 506
19.1.2 TCP/IP参考模型 506
19.1.3 IP地址 507
19.1.4 数据包格式 508


#### 19.2 套接字
19.2.1 Winsocket套接字 510
19.2.2 Winsocket的使用 510
19.2.3 套接字阻塞模式 515
19.2.4 字节顺序 515
19.2.5 面向连接流 516
19.2.6 面向无连接流 516


#### 19.3 简单协议通信




## 参考：
- https://coding.imooc.com/class/chapter/414.html#Anchor
- http://gz.mobiletrain.org/sem/xk/wlw/c1.html?quanguo=wlwbdtg=45413543-404-visitB20231025016613&jzl_kwd=762108459412&jzl_ctv=83855904859&jzl_ch=11&jzl_act=45413543&jzl_cpg=388370563&jzl_adp=9090237784&jzl_sty=16&jzl_dv=1&bd_vid=7298289407111102475






